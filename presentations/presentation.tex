\documentclass{beamer}
\usetheme{CambridgeUS}
\usepackage {preamble}
\begin{document}

\author{Потапкина Маргарита, КНиИТ, 251}
\title{Сортировка подсчётом. Различные реализации}
\date{}
\maketitle

\begin{frame}
\frametitle{Общие сведения}
\justifying Сортировка подсчётом "--- алгоритм сортировки целых чисел в некотором заданном диапазоне. Асимптотика сортировки подсчётом составляет $O(n + k)$, где $n$ "--- количество элементов, а $k$ "--- размер диапазона. В отличие от большинства алгоритмов сортировки, сортировка подсчётом не основана на сравнениях элементов, что и позволяет достичь линейной асимптотики (при использовании сравнений невозможно достичь асимптотики, лучшей чем $O(n \cdot log n)$).
\end{frame}

\begin{frame}
\frametitle{Сравнение асимптотики различных сортировок}
\begin{figure}
	\includegraphics[scale=0.5]{comparison.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Алгоритм}
\begin{enumerate}
	\justifying
	\item Найдём границы диапазона чисел, содержащихся в массиве $a$ (минимальный и максимальный элементы).
	\item Создадим массив частот размера $max(a) - min(a) + 1$.
	\item Обработаем все числа массива $a$, для каждого числа сделаем прибавление в массиве частот по индексу, соответствующему значению элемента, уменьшенному на минимум (так минимум будет сопоставлен с $0$, это позволяет обрабатывать в том числе отрицательные числа).
	\item Заведём счётчик, указывающий на текущий индекс элемента.
	\item Пройдёмся по всем числам от $0$ до $max(a) - min(a)$. Во внутреннем цикле, выполняющемся такое количество раз, которое записано в массиве частот для текущего числа, присвоим текущему элементу $a$ значение данного числа, увеличенного на минимум (так мы вернёмся к исходным значениям массива). Инкрементируем текущий индекс для массива $a$.
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Иллюстрация алгоритма}
\begin{figure}
	\includegraphics[scale=0.45]{counting_sort.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Анализ асимптотики всех шагов алгоритма}
\begin{columns}
	\begin{column}{0.52\textwidth}
	\begin{enumerate}
		\item Поиск максимума и минимума в исходном массиве "--- $O(n)$
		\item Создание и заполнение массива частот "--- $O(n + k)$
		\item Основной внешний цикл по всем числам диапазона "--- $O(k)$
		\item Внутренний цикл "--- $O(n)$ суммарно для всех итераций внешнего цикла.
	\end{enumerate}
	\justifying Итого асимптотика алгоритма составляет $O(n + k)$. 
	\end{column}
	\begin{column}{0.48\textwidth}
	\begin{figure}
		\includegraphics[scale=0.2]{complexity.png}
	\end{figure}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Простейшая реализация}
Эта реализация сортировки подсчётом применяется только для неотрицательных чисел, её асимптотика составляет $O(n + max(a))$.
\inputminted{cpp}{./counting_sort_positive.cpp}
\end{frame}

\begin{frame}
\frametitle{Реализация с учётом отрицательных чисел}
\small
\justifying Эта реализация сортировки подсчётом может применяться для массива, состоящего из произвольных целых чисел, в ней все числа нормализуются так, что минимум сопоставляется с $0$, а остальные числа уменьшаются на значение минимума. Помимо работы с отрицательными числами такая сортировка также позволяет обрабатывать даже очень большие числа, если сам их диапазон невелик. Асимптотика такой реализации составляет $O(n + k)$, где $k = max(a) - min(a)$.
\inputminted{cpp}{./counting_sort_universal.cpp}
\normalsize
\end{frame}

\begin{frame}
\frametitle{Сортировка сложных данных}
\justifying Сортировку подсчётом также можно использовать для сортировки структур. Она является устойчивой, т.е. структуры, имеющие одинаковый ключ (по которому и происходит сортировка), сохраняют свой относительный порядок: в результирующем массиве они следуют в том же порядке, что и в исходном. Для простоты продемонстрируем его работу при условии, что ключ, по которому происходит сортировка, неотрицателен, на отрицательные числа алгоритм адаптируется аналогичным способом. Этот алгоритм можно реализовать в двух вариантах.
\begin{figure}
	\includegraphics[scale=0.55]{prefsums.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Первый способ}
\begin{enumerate}
	\justifying
	\item Создадим массив, элементами которого изначально являются пустые вектора. Размер массива совпадает с размером диапазона.
	\item Пройдёмся по исходному массиву и в вектор массива частот, соответствующий ключу текущего элемента, добавим данную структуру.
	\item Заведём счётчик, указывающий на индекс текущего элемента.
	\item Пройдёмся по массиву частот в порядке возрастания ключей. Во внутреннем цикле пройдёмся по всем элементам соответствующего вектора и выпишем их в результирующий массив, каждый раз увеличивая текущий индекс.
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Второй способ (без двумерных массивов)}
\begin{enumerate}
	\justifying
	\item Создадим массив частот и заполним его.
	\item Создадим вспомогательный массив с префиксными суммами по массиву частот. Они указывают, с какой позиции в результирующем массиве должен начинаться блок элементов с заданным ключом.
	\item Пройдёмся по исходному массиву. Запишем текущий элемент по индексу, соответствующему префиксной сумме по этому ключу, изначально она указывает на позицию, до которой уже должны стоять все элементы с меньшими ключами, а начиная с неё "--- с большими или равными. После записи увеличим эту префиксную сумму на 1, чтобы сдвинуться в данном блоке.
\end{enumerate}
	\justifying Так как мы записываем элементы в каждом блоке в том порядке, в каком они встретились в исходном массиве, сортировка является устойчивой. Такой вариант сортировки применяется в частности в поразрядной сортировке (\textbf{Radix Sort}), для сортировки чисел по отдельным разрядам она использует сортировку подсчётом, опираясь на факт её устойчивости.
\end{frame}

\end{document}
