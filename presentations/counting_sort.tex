\documentclass{article}

\usepackage {preamble}

\begin{document}

\author{Потапкина Маргарита, КНиИТ, 251}
\title{Сортировка подсчётом. Различные реализации}
\date{21.02.2026}
\maketitle

\section{Общие сведения}
Сортировка подсчётом "--- алгоритм сортировки целых чисел в некотором заданном диапазоне. Асимптотика сортировки подсчётом составляет $O(n + k)$, где $n$ "--- количество элементов, а $k$ "--- размер диапазона. В отличие от большинства алгоритмов сортировки, сортировка подсчётом не основана на сравнениях элементов, что и позволяет достичь линейной асимптотики (при использовании сравнений невозможно достичь асимптотики, лучшей чем $O(n log n)$).

\section{Алгоритм}
\begin{enumerate}
	\item Найдём границы диапазона чисел, содержащихся в массиве $a$ (минимальный и максимальный элементы).
	\item Создадим массив частот размера $max(a) - min(a) + 1$.
	\item Обработаем все числа массива $a$, для каждого числа сделаем прибавление в массиве частот по индексу, соответствующему значению элемента, уменьшенному на минимум (так минимум будет сопоставлен $0$, это позволяет обрабатывать в том числе отрицательные числа).
	\item Заведём счётчик, указывающий на текущий индекс элемента.
	\item Пройдёмся по всем числам от $0$ до $max(a) - min(a)$. Во внутреннем цикле, выполняющемся такое количество раз, которое записано в массиве частот для текущего числа, присвоим текущему элементу $a$ значение данного числа, увеличенного на минимум (так мы вернёмся к исходным значениям массива). Инкрементируем текущий индекс для массива $a$.
\end{enumerate}

\section{Анализ асимптотики всех шагов алгоритма}
\begin{enumerate}
	\item Поиск максимума и минимума в исходном массиве "--- $O(n)$
	\item Создание массива частот "--- $O(k)$
	\item Заполнение массива частот "--- $O(n)$
	\item Основной внешний цикл по всем числам диапазона "--- $O(k)$
	\item Внутренний цикл "--- $O(n)$ суммарно для всех итераций внешнего цикла.
\end{enumerate}

Итого асимптотика алгоритма составляет $O(n + k)$. Помимо этого, алгоритм использует $O(k)$ дополнительной памяти на создание массива частот.

\section{Простейшая реализация (только для неотрицательных чисел)}
Эта реализация сортировки подсчётом применяется только для неотрицательных чисел, её асимптотика составляет $O(n + max(a))$.
\inputminted{cpp}{./counting_sort_positive.cpp}

\section{Реализация для любых целых чисел, в т.ч. отрицательных}
Эта реализация сортировки подсчётом может применяться для массива, состоящего как из положительных, так и из отрицательных чисел, в ней все числа нормализуются так, что минимум сопоставляется с $0$, а остальные числа уменьшаются на значение минимума. Помимо работы с отрицательными числами такая сортировка также позволяет обрабатывать даже очень большие числа, если сам их диапазон невелик. Асимптотика такой реализации составляет $O(n + k)$, где $k = max(a) - min(a)$.
\inputminted{cpp}{./counting_sort_universal.cpp}

\section{Сортировка сложных данных}
Сортировку подсчётом также можно использовать для сортировки структур. Она является устойчивой, т.е. структуры, имеющие одинаковый ключ (по которому и происходит сортировка), сохраняют свой относительный порядок: в результирующем массиве они следуют в том же порядке, что и в исходном. Для простоты продемонстрируем его работу при условии, что ключ, по которому происходит сортировка, неотрицателен, на отрицательные числа алгоритм адаптируется аналогичным способом. Возможно реализовать этот алгоритм в двух вариантах.
 
\subsection{Первый способ}
\begin{enumerate}
\item Создадим массив, элементами которого изначально являются пустые вектора. Размер массива совпадает с размером диапазона.
\item Пройдёмся по исходному массиву и в вектор массива частот, соответствующий ключу текущего элемента, добавим данную структуру.
\item Заведём счётчик, указывающий на индекс текущего элемента.
\item Пройдёмся по массиву частот в порядке возрастания ключей. Во внутреннем цикле пройдёмся по всем элементам соответствующего вектора и выпишем их в результирующий массив, каждый раз увеличивая текущий индекс.
\end{enumerate}

\subsection{Второй способ}
Этот способ не использует массивов с двумерной вложенностью, однако также является устойчивым.

\begin{enumerate}
\item Создадим массив частот и заполним его.
\item Создадим вспомогательный массив с префиксными суммами по массиву частот. Они указывают, с какой позиции в результирующем массиве должен начинаться блок элементов с заданным ключом.
\item Пройдёмся по исходному массиву. Запишем текущий элемент по индексу, соответствующему префиксной сумме по этому ключу, изначально она указывает на позицию, до которой уже должны стоять все элементы с меньшими ключами, а начиная с неё "--- с большими или равными. После записи увеличим эту префиксную сумму на 1, чтобы сдвинуться в данном блоке.
\end{enumerate}

Так как мы записываем элементы в каждом блоке в том порядке, в каком они встретились в исходном массиве, сортировка является устойчивой. Такой вариант сортировки применяется, в частности, в поразрядной сортировке (Radix Sort), для сортировки чисел по отдельным разрядам она использует сортировку подсчётом, опираясь на факт её устойчивости.

\end{document}
